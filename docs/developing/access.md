# Access Control for Developers

Nova 3 includes a granular and flexible access control system that gives game masters more control than they've ever had over what their players can access. As developers, the same granularity and flexibility is available to you for your custom solutions.

## Sentry

Sentry is a simple, powerful and easy to use authentication and authorization package from Cartalyst that, in addition to authorization and authentication, provides additional features such as groups, permissions, custom hashing algorithms and additional security features.

We chose this solution for Nova's access control because of its ease of use, easy integration with Laravel 4 and flexibility to change to what Nova needs. The majority of functionality from Sentry 2 works as advertised in their [documentation](http://docs.cartalyst.com/sentry-2), but it's important to note that some methods are different than Sentry's defaults because of Nova's unique access control requirements. The Sentry 2 documentation is a good place to start for more advanced authorization functions. Below are some of the more common methods you'll likely want to use in your custom solutions.

### check()

The `check()` method is used to check whether the current user is logged in or not. This returns `TRUE` if the user is logged in and `FALSE` if they aren't. A user must be activated in order to pass `check()`.

<pre>if (Sentry::check())
{
	// User is logged in, do something
}</pre>

### getUser()

The `getUser()` method retrieves the current logged in user object (from the User model), but will __not__ check if the user is logged in first. You should always run `check()` before attempting to get the user object.

<pre>$user = Sentry::getUser();</pre>

Once the user has been retrieved, you'll have access to all the methods and relationships attached to the User object.

### allowed()

The `allowed()` method checks the current user to see if they're allowed to access the page.

<pre>$user->allowed('user.edit');</pre>

Instead of a simple string, you can also pass an array of access keys to see if the user has access to any of the items.

<pre>$user->allowed(['user.create', 'user.delete']);</pre>

A second parameter on the `allowed()` method lets you choose to redirect the user to the error page if they aren't allowed to access the page they're trying to get to. The default behavior is to __not__ redirect the user to the error page.

<pre>$user->allowed(['user.create', 'user.delete'], true);</pre>

In addition to redirecting to the error page, if a user isn't logged in and the second parameter is set to `TRUE`, they'll be redirected to the log in page.

### hasLevel()/hasAtLeastLevel()

The `hasLevel()` checks the current logged in user to see if they have _the exact_ level that's passed to this method. If the user has something lower or higher than the passed value, the check will fail.

<pre>if ($user->hasLevel('user.edit', 2))
{
	// User has user.edit level 2 permissions, do something
}</pre>

In addition, there is also a `hasAtLeastLevel()` method that doesn't do a strict check and will make sure the user has a level for that access key at or higher than what's passed to the method.

<pre>if ($user->hasAtLeastLevel('character.edit', 2))
{
	// User has at least character.edit level 2 permissions or higher, do something
}</pre>

## Integrating Nova Access Control Into Your Custom Solutions

Because of the flexible nature of Nova's access control system, you can incorporate access control into your custom solutions without much work. You have two options when it comes to integrating access control:

- Use existing access keys and levels
- Create your own access keys and levels

<p class="alert"><strong>Note:</strong> You should never create a new level for an existing access key. In the future, we may expand on existing access keys and create conflicts in your custom solution.</p>

Using existing access keys is the easiest and fastest way to get access control into your custom solutions. You can simply use the component and action item combination you want. For example, if you wanted your custom solution to follow the same model editing a user, you could create something like the below at the top of your controller method:

<pre>public function getIndex()
{
	Sentry::allowed('user.edit', true);

	if (Sentry::getUser()->hasLevel('user.edit', 2))
	{
		// Do something
	}
}</pre>

Sometimes though, tapping in to existing access keys doesn't quite cut it. In those situations, you can create your own access keys in a migration for your custom solution. (Make sure you read the section on creating your own migrations if you haven't already.)

In your migration's `up()` method, you can create a new access key like this:

<pre>AccessTask::add([
	'action'	=> 'read',
	'component'	=> 'reportGen',
	'level'		=> 0,
	'name'		=> 'View generated reports',
	'desc'		=> 'Allows users to view any reports generated by the reporter generator.'
]);</pre>

You can create as many new keys as you want in a similar way including more actions and more levels in the same component.

<p class="alert alert-info"><strong>Note:</strong> Make sure you provide a unique `component` name so as not to conflict with Nova's built-in components.</p>

The inverse is just as important. In your migration's `down()` method, you __must__ remove those access keys in the event your custom solution is uninstalled.

<pre>// Get all the tasks in the reportGen component
$tasks = AccessTask::where('component', 'reportGen')->get();

// This will remove the tasks for any roles they're attached to
$tasks->roles()->detach();

// Loop through the tasks and delete them
foreach ($tasks as $task)
{
	$task->delete();
}</pre>